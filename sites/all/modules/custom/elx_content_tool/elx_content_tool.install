<?php

/**
 * @file
 * Migration scripts for ELX content.
 */

/**
 * Implements hook_install().
 */
function elx_content_tool_install() {
  // Mark as needing updates.
  drupal_set_installed_schema_version('elx_content_tool_install', SCHEMA_INSTALLED);
}

/**
 * Switch from field translations to translation nodes.
 */
function elx_content_tool_update_7100() {
  foreach (node_type_get_types() as $node_type) {
    if (variable_get("language_content_type_$node_type->type", 0) == ENTITY_TRANSLATION_ENABLED) {
      variable_set("language_content_type_$node_type->type", TRANSLATION_ENABLED);
    }
  }
}

/**
 * Create a translation node for each field translation.
 */
function elx_content_tool_update_7101(&$sandbox) {
  if (module_exists('entity_translation')) {
    if (!isset($sandbox['progress'])) {
      $sandbox['progress'] = 0;
      $query = db_select('node', 'n');
      $query->join('entity_translation', 't', 'n.nid = t.entity_id');
      $sandbox['max'] = $query
        ->condition('t.entity_type', 'node')
        ->condition('t.source', '', '<>')
        ->countQuery()
        ->execute()
        ->fetchField();
      // Load node reference fields. They need to be updated to reference the
      // translation nodes.
      $sandbox['node_references'] = array();
      foreach (field_read_fields(array('type' => 'entityreference')) as $field_name => $field) {
        if ($field['translatable'] && $field['settings']['target_type'] == 'node') {
          $sandbox['node_references'][$field_name] = $field;
        }
      }
    }
    $query = db_select('node', 'n');
    $query->join('entity_translation', 't', 'n.nid = t.entity_id');
    $result = $query
      ->fields('t')
      ->condition('t.entity_type', 'node')
      ->condition('t.source', '', '<>')
      ->range(0, 1)
      ->execute();
    foreach ($result as $translation) {
      // Load translation source node.
      $source_node = node_load($translation->entity_id);
      $author = user_load($translation->uid);
      $form_state['values']['op'] = t('Save');
      form_load_include($form_state, 'pages.inc', 'node');
      // Check for existing translation nodes.
      $translations = translation_node_get_translations($source_node->nid);
      if (isset($translations[$translation->language])) {
        $node = $translations[$translation->language];
        $node->tnid = $source_node->nid;
      }
      else {
        // If there is no existing translation node, create an empty object.
        $node = new stdClass();
      }
      $node->log = t('Converted field translation to node translation.');
      $node->type = $source_node->type;
      $node->name = $author->name;
      $node->date = format_date($translation->created, 'custom', 'Y-m-d H:i:s O');
      $node->changed = $translation->changed;
      $node->status = $translation->status;
      $node->promote = $source_node->promote;
      $node->sticky = $source_node->sticky;
      $node->comment = $source_node->comment;
      $node->language = $translation->language;
      $node->translation_source = $source_node;
      $node->title = $source_node->title;
      if (module_exists('title') && title_field_replacement_enabled('node', $source_node->type, 'title')) {
        $title = title_entity_label($source_node, 'node', $translation->language);
        if (!empty($title)) {
          $node->title = $title;
        }
      }
      // In case required fields were not translated, copy values from source
      // fields.
      field_attach_prepare_translation('node', $node, $translation->language, $source_node, $source_node->language);
      // Copy values from the translated fields.
      field_attach_prepare_translation('node', $node, $translation->language, $source_node, $translation->language);
      // Messages generated by saving a translation node will be skipped
      // because the translation node should match the entity translation,
      // including data errors. Save previous messages before starting.
      $messages = drupal_get_messages();
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        // Ensure saved messages are restored even if there is an error.
        try {
          // Save translation node.
          drupal_form_submit($node->type . '_node_form', $form_state, $node);
          $errors = form_get_errors();
          if (!empty($errors)) {
            throw new DrupalUpdateException(implode("\n", $errors));
          }
          // Restore saved messages.
          $_SESSION['messages'] = $messages;
        }
        catch (Exception $e) {
          // Restore saved messages.
          $_SESSION['messages'] = $messages;
          throw $e;
        }
        // Check for successful translation node creation.
        if (isset($node->tnid) && $node->tnid == $source_node->nid) {
          // Make sure original translation status is saved.
          if (empty($node->translate) && !empty($translation->translate) || !empty($node->translate) && $node->translate != $translation->translate) {
            $node->translate = $translation->translate;
            translation_node_update($node);
          }
          // Update node references in this language to point to the translation
          // node.
          foreach ($sandbox['node_references'] as $field_name => $field) {
            $query = new EntityFieldQuery();
            $result = $query
              ->fieldCondition($field, 'target_id', $node->tnid)
              ->fieldLanguageCondition($field, $translation->language)
              ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')
              ->execute();
            foreach ($result as $entity_type => $entities) {
              field_attach_load($entity_type, $entities, FIELD_LOAD_CURRENT, array('field_id' => $field['id']));
              foreach ($entities as $entity) {
                foreach ($entity->{$field_name}[$translation->language] as &$item) {
                  if ($item['target_id'] == $node->tnid) {
                    $item['target_id'] = $node->nid;
                  }
                }
                field_attach_update($entity_type, $entity);
              }
              entity_get_controller($entity_type)->resetCache();
            }
          }
          // Remove entity translation.
          $handler = entity_translation_get_handler('node', $source_node);
          $source_node->original = $source_node;
          $handler->removeTranslation($translation->language);
          entity_translation_sync('node', $source_node);
          $handler->updateTranslations();
          $handler->saveTranslations();
          ++$sandbox['progress'];
        }
        else {
          throw new DrupalUpdateException('Failed to create translation node.');
        }
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
    if (!empty($sandbox['max'])) {
      $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
    }
  }
}

/**
 * Add markets group to content types.
 */
function elx_content_tool_update_7102(&$sandbox) {
  $markets = field_info_field('markets');
  $field_markets = field_info_field('field_markets');
  if (!isset($sandbox['progress'])) {
    // Count markets groups that match old markets fields.
    $sandbox['progress'] = 0;
    foreach ($markets['bundles'] as $entity_type => $bundles) {
      if (isset($field_markets['bundles'][$entity_type])) {
        $sandbox['progress'] += count(array_intersect($bundles, $field_markets['bundles'][$entity_type]));
      }
    }
    // Get the total number of old markets fields.
    $sandbox['max'] = array_sum(array_map('count', $field_markets['bundles']));
  }
  foreach ($field_markets['bundles'] as $entity_type => $bundles) {
    // Add the OG markets field to bundles that do not have it.
    foreach (array_diff($bundles, isset($markets['bundles'][$entity_type]) ? $markets['bundles'][$entity_type] : array()) as $bundle) {
      $og_field = og_fields_info('og_group_ref');
      $og_field['instance']['label'] = 'Markets';
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        og_create_field('markets', $entity_type, $bundle, $og_field);
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
      break 2;
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Add groups access field to content types.
 */
function elx_content_tool_update_7103(&$sandbox) {
  $group_content_access = field_info_field('group_content_access');
  $field_markets = field_info_field('field_markets');
  if (!isset($sandbox['progress'])) {
    // Count OG markets fields that match old markets fields.
    $sandbox['progress'] = 0;
    foreach ($group_content_access['bundles'] as $entity_type => $bundles) {
      if (isset($field_markets['bundles'][$entity_type])) {
        $sandbox['progress'] += count(array_intersect($bundles, $field_markets['bundles'][$entity_type]));
      }
    }
    // Get total number of old markets fields.
    $sandbox['max'] = array_sum(array_map('count', $field_markets['bundles']));
  }
  foreach ($field_markets['bundles'] as $entity_type => $bundles) {
    // Add groups access field to bundles that do not have it.
    foreach (array_diff($bundles, isset($group_content_access['bundles'][$entity_type]) ? $group_content_access['bundles'][$entity_type] : array()) as $bundle) {
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        og_create_field('group_content_access', $entity_type, $bundle);
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
      break 2;
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Create table to map old market options to new market groups.
 */
function elx_content_tool_update_7104() {
  // Use a transaction so we can clean up errors.
  $transaction = db_transaction();
  try {
    db_create_table('elx_content_tool_markets_map', array(
      'description' => 'Temporary table to map market options to market groups.',
      'fields' => array(
        'market' => array(
          'description' => 'field_markets value.',
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
        ),
        'nid' => array(
          'description' => 'Market group {node}.nid.',
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
        ),
      ),
      'primary key' => array('market'),
    ));
    // Map old market options to new market groups.
    $query = db_insert('elx_content_tool_markets_map')
      ->fields(array('market', 'nid'));
    $market_options = array();
    foreach (array('field_markets', 'field_market_name') as $field_name) {
      $field_markets = field_info_field($field_name);
      if (isset($field_markets['settings']['allowed_values'])) {
        $market_options += $field_markets['settings']['allowed_values'];
      }
    }
    // Handle market typos.
    $market_options['Colombia-Ecuador-Central America '] = 'Colombia - Ecuador - Central America';
    $market_options['Eau Claire'] = 'Eau Claire';
    $market_options['en'] = 'United States';
    $market_options['English'] = 'United States';
    $market_options['Ireland'] = 'Ireland';
    $market_options['KRn'] = 'Korea';
    $market_options['NOAM'] = 'Travel Retail Americas - North America';
    $market_options['Southern Cone-Chile-Peru-Argentina'] = 'Southern Cone - Chile - Peru - Argentina';
    $market_options['TR MY'] = 'TR Malaysia';
    $market_options['TR SG'] = 'TR Singapore';
    $market_options['TR TH'] = 'TR Thailand';
    $market_options['Travel Retail CN'] = 'Travel Retail China';
    $market_options['Travel Retail HK-Macau-TW'] = 'Travel Retail Hong Kong-Macau-Taiwan';
    $market_options['Travel Retail JP'] = 'Travel Retail Japan';
    $market_options['Travel Retail KR'] = 'Travel Retail Korea';
    $market_options['TRRAM-CC'] = 'Travel Retail Americas - Caribbean - Cancun';
    $market_options['U.K.'] = 'U.K.';
    $market_options['unisted states'] = 'United States';
    $market_options['ZAe'] = 'South Africa';
    $market_groups = db_select('node', 'n')
      ->fields('n', array('title', 'nid'))
      ->condition('n.type', 'market')
      ->execute()
      ->fetchAllKeyed();
    foreach ($market_options as $option => $name) {
      if (isset($market_groups[$name])) {
        $query->values(array(
          'market' => $option,
          'nid' => $market_groups[$name],
        ));
      }
    }
    $query->execute();
  }
  catch (Exception $e) {
    $transaction->rollback();
    throw $e;
  }
}

/**
 * Switch old field_markets values to new markets groups.
 */
function elx_content_tool_update_7105(&$sandbox) {
  $field = field_info_field('field_markets');
  $table = _field_sql_storage_tablename($field);
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['max'] = 0;
    foreach ($field['bundles'] as $entity_type => $bundles) {
      $info = entity_get_info($entity_type);
      // Get the number of values that have been switched to market groups.
      $query = db_select($info['base table'], 'b');
      $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', 'f.field_markets_value = s.market');
      $query->join('og_membership', 'g', 'b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid');
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $sandbox['progress'] += $query
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->condition('g.entity_type', $entity_type)
        ->condition('g.status', 1)
        ->countQuery()
        ->execute()
        ->fetchField();
      // Get the total number of old market values.
      $query = db_select($info['base table'], 'b');
      $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', 'f.field_markets_value = s.market');
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $sandbox['max'] += $query
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->countQuery()
        ->execute()
        ->fetchField();
    }
  }
  foreach ($field['bundles'] as $entity_type => $bundles) {
    $info = entity_get_info($entity_type);
    // Find an entity that is missing market groups.
    $query = db_select($info['base table'], 'b');
    $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
    $query->join('elx_content_tool_markets_map', 's', 'f.field_markets_value = s.market');
    $query->leftJoin('og_membership', 'g', 'g.entity_type = :entity_type AND b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid', array(
      ':entity_type' => $entity_type,
    ));
    if (isset($info['entity keys']['language'])) {
      $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
    }
    $query
      ->fields('b', array($info['entity keys']['id']))
      ->condition('f.entity_type', $entity_type)
      ->condition('f.deleted', 0)
      ->condition(db_or()
        ->condition('g.status', 0)
        ->isNull('g.etid')
      )
      ->range(0, 1);
    foreach (entity_load($entity_type, $query->execute()->fetchCol()) as $entity) {
      // Get new market groups to add.
      $query = db_select($info['base table'], 'b');
      $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', 'f.field_markets_value = s.market');
      $query->leftJoin('og_membership', 'g', 'g.entity_type = :entity_type AND b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid', array(
        ':entity_type' => $entity_type,
      ));
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $markets = $query
        ->fields('s', array('nid'))
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->condition(db_or()
          ->condition('g.status', 0)
          ->isNull('g.etid')
        )
        ->condition('b.' . $info['entity keys']['id'], $entity->{$info['entity keys']['id']})
        ->execute()
        ->fetchCol();
      // Set market groups.
      foreach ($markets as $nid) {
        $entity->markets[LANGUAGE_NONE][] = array('target_id' => $nid);
      }
      // Clear entity cache.
      entity_get_controller($entity_type)->resetCache(array(
        $entity->{$info['entity keys']['id']},
      ));
      // Save market groups. Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        foreach ($markets as $nid) {
          $og_membership = og_membership_create('node', $nid, $entity_type, $entity->{$info['entity keys']['id']}, 'markets', array('language' => LANGUAGE_NONE));
          $og_membership->entity = $entity;
          $og_membership->save();
          // Add new market group to processed count.
          ++$sandbox['progress'];
        }
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Remove field_markets field.
 */
function elx_content_tool_update_7106() {
  field_delete_field('field_markets');
}

/**
 * Switch old field_market_name values to new markets groups.
 */
function elx_content_tool_update_7107(&$sandbox) {
  $field = field_info_field('field_market_name');
  $table = _field_sql_storage_tablename($field);
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['max'] = 0;
    foreach ($field['bundles'] as $entity_type => $bundles) {
      $info = entity_get_info($entity_type);
      // Get the number of values that have been switched to market groups.
      $query = db_select($info['base table'], 'b');
      $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', 'f.field_market_name_value = s.market');
      $query->join('og_membership', 'g', 'b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid');
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $sandbox['progress'] += $query
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->condition('g.entity_type', $entity_type)
        ->condition('g.state', 1)
        ->countQuery()
        ->execute()
        ->fetchField();
      // Get the total number of old market values.
      $query = db_select($info['base table'], 'b');
      $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', 'f.field_market_name_value = s.market');
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $sandbox['max'] += $query
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->countQuery()
        ->execute()
        ->fetchField();
    }
  }
  foreach ($field['bundles'] as $entity_type => $bundles) {
    $field_name = $entity_type == 'user' ? 'og_user_node' : 'markets';
    $info = entity_get_info($entity_type);
    // Find an entity that is missing market groups.
    $query = db_select($info['base table'], 'b');
    $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
    $query->join('elx_content_tool_markets_map', 's', 'f.field_market_name_value = s.market');
    $query->leftJoin('og_membership', 'g', 'g.entity_type = :entity_type AND b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid', array(
      ':entity_type' => $entity_type,
    ));
    if (isset($info['entity keys']['language'])) {
      $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
    }
    $query
      ->fields('b', array($info['entity keys']['id']))
      ->condition('f.entity_type', $entity_type)
      ->condition('f.deleted', 0)
      ->condition(db_or()
        ->condition('g.state', 0)
        ->isNull('g.etid')
      )
      ->range(0, 1);
    foreach (entity_load($entity_type, $query->execute()->fetchCol()) as $entity) {
      // Get new market groups to add.
      $query = db_select($info['base table'], 'b');
      $query->join($table, 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', 'f.field_market_name_value = s.market');
      $query->leftJoin('og_membership', 'g', 'g.entity_type = :entity_type AND b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid', array(
        ':entity_type' => $entity_type,
      ));
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $markets = $query
        ->fields('s', array('nid'))
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->condition(db_or()
          ->condition('g.state', 0)
          ->isNull('g.etid')
        )
        ->condition('b.' . $info['entity keys']['id'], $entity->{$info['entity keys']['id']})
        ->execute()
        ->fetchCol();
      // Set market groups.
      foreach ($markets as $nid) {
        $entity->{$field_name}[LANGUAGE_NONE][] = array('target_id' => $nid);
      }
      // Clear entity cache.
      entity_get_controller($entity_type)->resetCache(array(
        $entity->{$info['entity keys']['id']},
      ));
      // Save market groups. Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        foreach ($markets as $nid) {
          $og_membership = og_membership_create('node', $nid, $entity_type, $entity->{$info['entity keys']['id']}, $field_name, array('language' => LANGUAGE_NONE));
          $og_membership->entity = $entity;
          $og_membership->save();
          // Add new market group to processed count.
          ++$sandbox['progress'];
        }
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Drop market value mapping table and remove old field_market_name field.
 */
function elx_content_tool_update_7108() {
  db_drop_table('elx_content_tool_markets_map');
  field_delete_field('field_market_name');
}
